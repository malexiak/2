"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sessionMiddleware = void 0;
const deps_js_1 = require("../deps.js");
const CookieStore_js_1 = __importDefault(require("./store/CookieStore.js"));
const mod_js_1 = require("../mod.js");
/** Function that returns a Hono-compatible session middleware */
function sessionMiddleware(options) {
    const store = options.store;
    const encryptionKey = options.encryptionKey;
    const expireAfterSeconds = options.expireAfterSeconds;
    const cookieOptions = options.cookieOptions;
    const sessionCookieName = options.sessionCookieName || 'session';
    if (store instanceof CookieStore_js_1.default) {
        store.sessionCookieName = sessionCookieName;
        if (encryptionKey) {
            store.encryptionKey = encryptionKey;
        }
        else {
            throw new Error('encryptionKey is required while using CookieStore. encryptionKey must be at least 32 characters long.');
        }
        if (cookieOptions) {
            store.cookieOptions = cookieOptions;
        }
    }
    const middleware = (0, deps_js_1.createMiddleware)(async (c, next) => {
        const session = new mod_js_1.Session;
        let sid = '';
        let session_data;
        let createNewSession = false;
        const sessionCookie = (0, deps_js_1.getCookie)(c, sessionCookieName);
        if (sessionCookie) { // If there is a session cookie present...
            if (store instanceof CookieStore_js_1.default) {
                session_data = await store.getSession(c);
            }
            else {
                try {
                    sid = (encryptionKey ? await (0, mod_js_1.decrypt)(encryptionKey, sessionCookie) : sessionCookie);
                    session_data = await store.getSessionById(sid);
                }
                catch {
                    createNewSession = true;
                }
            }
            if (session_data) {
                session.setCache(session_data);
                if (session.sessionValid()) {
                    session.reupSession(expireAfterSeconds);
                }
                else {
                    store instanceof CookieStore_js_1.default ? await store.deleteSession(c) : await store.deleteSession(sid);
                    createNewSession = true;
                }
            }
            else {
                createNewSession = true;
            }
        }
        else {
            createNewSession = true;
        }
        if (createNewSession) {
            const defaultData = {
                _data: {},
                _expire: null,
                _delete: false,
                _accessed: null,
            };
            if (store instanceof CookieStore_js_1.default) {
                await store.createSession(c, defaultData);
            }
            else {
                sid = globalThis.crypto.randomUUID();
                await store.createSession(sid, defaultData);
            }
            session.setCache(defaultData);
        }
        if (!(store instanceof CookieStore_js_1.default)) {
            (0, deps_js_1.setCookie)(c, sessionCookieName, encryptionKey ? await (0, mod_js_1.encrypt)(encryptionKey, sid) : sid, cookieOptions);
        }
        session.updateAccess();
        c.set('session', session);
        await next();
        const shouldDelete = session.getCache()._delete;
        const shouldRotateSessionKey = c.get("session_key_rotation") === true;
        const storeIsCookieStore = store instanceof CookieStore_js_1.default;
        if (shouldDelete) {
            store instanceof CookieStore_js_1.default
                ? await store.deleteSession(c)
                : await store.deleteSession(sid);
        }
        /*
         * Only update session data if we didn't just delete it.
         * If session key rotation is enabled and the store is not a CookieStore,
         * we need to roate the session key by deleting the old session and creating a new one.
         */
        const shouldRecreateSessionForNonCookieStore = !shouldDelete &&
            !storeIsCookieStore &&
            shouldRotateSessionKey;
        if (shouldRecreateSessionForNonCookieStore) {
            await store.deleteSession(sid);
            sid = globalThis.crypto.randomUUID();
            await store.createSession(sid, session.getCache());
            (0, deps_js_1.setCookie)(c, sessionCookieName, encryptionKey ? await (0, mod_js_1.encrypt)(encryptionKey, sid) : sid, cookieOptions);
        }
        /*
         * We skip session data persistence if it was just deleted.
         * Only persist if we didn't just rotate the session key,
         * or the store is a CookieStore (which does not have its session key rotated)
         */
        const shouldPersistSession = !shouldDelete &&
            (!shouldRotateSessionKey || storeIsCookieStore);
        if (shouldPersistSession) {
            store instanceof CookieStore_js_1.default
                ? await store.persistSessionData(c, session.getCache())
                : await store.persistSessionData(sid, session.getCache());
        }
    });
    return middleware;
}
exports.sessionMiddleware = sessionMiddleware;
