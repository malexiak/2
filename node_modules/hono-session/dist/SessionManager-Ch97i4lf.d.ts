import { CookieOptions } from 'hono/utils/cookie';
import { Context } from 'hono';

interface Encoder {
    encode: (data: Record<string, any>, secret: string) => MaybePromise<string>;
    decode: (data: string, secret: string) => MaybePromise<Record<string, any> | null>;
}

interface SessionOptions {
    store?: SessionStore | null;
    encoder?: Encoder | null;
    secret?: string;
    maxAge?: number;
    cookieName?: string;
    cookieOptions?: CookieOptions;
}
type MaybePromise<T> = T | Promise<T>;
interface SessionStore {
    get: (sid: string, c: Context) => MaybePromise<Record<string, any> | null | undefined>;
    set: (sid: string, data: Record<string, any>, c: Context) => MaybePromise<unknown>;
    delete: (sid: string, c: Context) => MaybePromise<unknown>;
}

declare class Session {
    #private;
    _flashKeys?: string[];
    _expires: number;
    constructor(manager: SessionManager, data?: Record<string, any> | null);
    get hasChanged(): boolean;
    get isNew(): boolean;
    toJSON(): {
        [k: string]: any;
    };
    renew(maxAge?: number): void;
    regenerate(): Promise<Session>;
    /** Store a value in the session for only the next request */
    flash<T extends keyof this & string>(key: T, value: this[T]): void;
    /** Keep all flashed values for an extra request */
    reflash(): void;
    /** Remove flashed values from the previous request */
    ageFlash(): void;
}

declare class SessionManager {
    options: Required<SessionOptions>;
    ctx: Context;
    session?: Session | false;
    sessionKey?: string;
    forceCommit: boolean;
    constructor(options: Required<SessionOptions>, ctx: Context);
    get(): false | Session | null | undefined;
    set(value: any): void;
    create(data?: any, sessionKey?: string): void;
    initFromStore(): Promise<void>;
    initFromCookie(): Promise<void>;
    regenerate(): Promise<Session>;
    commit(): Promise<void>;
}

export { type SessionOptions as S, Session as a, SessionManager as b, type SessionStore as c };
