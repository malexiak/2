import { createMiddleware } from 'hono/factory';
import _debug from 'debug';
import { getCookie, deleteCookie, setCookie } from 'hono/cookie';
import * as Iron from 'iron-webcrypto';

const debug = _debug("hono-session");
const secondsInADay = 24 * 60 * 60;

class Session {
  #manager;
  #initialState;
  #isNew;
  #oldFlashKeys;
  _flashKeys;
  _expires;
  constructor(manager, data) {
    this.#manager = manager;
    this._expires = Date.now() + manager.options.maxAge * 1e3;
    this.#isNew = !data;
    Object.assign(this, data);
    this.#initialState = JSON.stringify(this.toJSON());
    this.#oldFlashKeys = this._flashKeys;
    this._flashKeys = void 0;
  }
  get hasChanged() {
    return this.#initialState !== JSON.stringify(this.toJSON());
  }
  get isNew() {
    return this.#isNew;
  }
  toJSON() {
    return Object.fromEntries(
      Object.entries(this).filter(([_, value]) => !(value == null || (Array.isArray(value) ? !value.length : typeof value === "object" && !Object.keys(value).length)))
    );
  }
  renew(maxAge) {
    this._expires = Date.now() + (maxAge ?? this.#manager.options.maxAge) * 1e3;
    this.#manager.forceCommit = true;
  }
  async regenerate() {
    return this.#manager.regenerate();
  }
  /** Store a value in the session for only the next request */
  flash(key, value) {
    this[key] = value;
    this._flashKeys ??= [];
    if (!this._flashKeys.includes(key))
      this._flashKeys.push(key);
    if (this.#oldFlashKeys) {
      const idx = this.#oldFlashKeys.indexOf(key);
      if (~idx)
        this.#oldFlashKeys.splice(idx, 1);
    }
  }
  /** Keep all flashed values for an extra request */
  reflash() {
    if (!this.#oldFlashKeys?.length)
      return;
    debug("keeping flashed keys", this.#oldFlashKeys, "and", this._flashKeys);
    const set = [...this.#oldFlashKeys];
    if (this._flashKeys?.length)
      set.push(...this._flashKeys);
    this._flashKeys = Array.from(new Set(set));
    this.#oldFlashKeys = void 0;
  }
  /** Remove flashed values from the previous request */
  ageFlash() {
    debug("clearing flashed keys", this.#oldFlashKeys);
    this.#oldFlashKeys?.forEach((key) => {
      this[key] = void 0;
    });
    this.#oldFlashKeys = this._flashKeys;
  }
}

class SessionManager {
  constructor(options, ctx) {
    this.options = options;
    this.ctx = ctx;
  }
  session;
  sessionKey;
  forceCommit = false;
  get() {
    debug("get", this.session);
    const session = this.session;
    if (session)
      return session;
    if (session === false)
      return null;
    this.create();
    return this.session;
  }
  set(value) {
    debug("set", value);
    if (value == null) {
      this.session = false;
    } else if (typeof value === "object") {
      this.create(value, this.sessionKey);
    } else {
      throw new TypeError("Session can only be set to an object or null");
    }
  }
  create(data, sessionKey) {
    debug("create session with data", data, "key", sessionKey);
    const expires = data?._expires;
    if (typeof expires === "number" && expires < Date.now()) {
      data = void 0;
      sessionKey = void 0;
    }
    this.session = data instanceof Session ? data : new Session(this, data);
    if (this.options.store)
      this.sessionKey = sessionKey || globalThis.crypto.randomUUID();
  }
  async initFromStore() {
    if (!this.options.store)
      return;
    const key = getCookie(this.ctx, this.options.cookieName);
    if (!key) {
      this.create();
      return;
    }
    const data = await this.options.store.get(key, this.ctx);
    this.create(data, key);
  }
  async initFromCookie() {
    if (!this.options.encoder)
      return;
    const decode = this.options.encoder.decode;
    const cookie = getCookie(this.ctx, this.options.cookieName);
    if (!cookie) {
      this.create();
      return;
    }
    let data;
    try {
      data = await decode(cookie, this.options.secret);
    } catch (err) {
      this.create();
    }
    this.create(data);
  }
  async regenerate() {
    const session = this.session;
    this.session = false;
    await this.commit();
    this.create(session);
    this.forceCommit = true;
    return this.session;
  }
  async commit() {
    if (!this.session) {
      if (this.session === false) {
        debug("removing session", this.sessionKey);
        if (this.options.store)
          await this.options.store.delete(this.sessionKey, this.ctx);
        deleteCookie(this.ctx, this.options.cookieName, this.options.cookieOptions);
      }
      return;
    }
    this.session.ageFlash();
    if (!this.session.hasChanged && !this.forceCommit) {
      debug("session has not been changed");
      return;
    }
    if (this.options.store) {
      debug("saving to store", this.sessionKey);
      await this.options.store.set(this.sessionKey, this.session.toJSON(), this.ctx);
      setCookie(this.ctx, this.options.cookieName, this.sessionKey, this.options.cookieOptions);
    } else {
      debug("saving to cookie");
      const encode = this.options.encoder.encode;
      setCookie(
        this.ctx,
        this.options.cookieName,
        await encode(this.session.toJSON(), this.options.secret),
        this.options.cookieOptions
      );
    }
  }
}

const defaultEncoder = {
  encode(data, secret) {
    return Iron.seal(globalThis.crypto, data, secret, Iron.defaults);
  },
  decode(data, secret) {
    return Iron.unseal(globalThis.crypto, data, secret, Iron.defaults);
  }
};

function index(_options) {
  const options = {
    encoder: defaultEncoder,
    maxAge: 1 * secondsInADay,
    cookieName: "sid",
    ..._options,
    cookieOptions: {
      secure: true,
      httpOnly: true,
      ..._options?.cookieOptions
    }
  };
  options.cookieOptions.maxAge ??= options.maxAge;
  options.secret ??= String.fromCodePoint(...globalThis.crypto.getRandomValues(new Uint8Array(32)));
  return createMiddleware(async (c, next) => {
    const manager = new SessionManager(options, c);
    if (options.store)
      await manager.initFromStore();
    else
      await manager.initFromCookie();
    Object.defineProperty(c, "session", {
      get: () => manager.get(),
      set: (value) => {
        manager.set(value);
      },
      enumerable: true,
      configurable: true
    });
    const get = c.get;
    const set = c.set;
    Object.defineProperty(c, "get", {
      value: (key) => {
        if (key === "session") {
          return manager.get();
        }
        return get(key);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(c, "set", {
      value: (key, value) => {
        if (key === "session") {
          manager.set(value);
          return;
        }
        set(key, value);
      },
      enumerable: true,
      configurable: true
    });
    try {
      await next();
    } finally {
      await manager.commit();
    }
  });
}

export { index as default };
//# sourceMappingURL=index.mjs.map
